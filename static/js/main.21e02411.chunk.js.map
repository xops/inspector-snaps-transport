{"version":3,"sources":["methods/methodMapping.ts","transports/MetaMaskTransport.ts","index.tsx"],"names":["transport","MetaMaskTransport","uri","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","window","ethereum","request","method","params","wallet_snap","defineProperty","results","data","Transport","internalID","methodMapping","connect","_ref","asyncToGenerator","regenerator_default","a","mark","_callee","wrap","_context","prev","next","abrupt","stop","_x","apply","arguments","sendData","Error","addEventListener","ev","console","log","origin","source","postMessage","jsonrpc","result","openrpcDocument","id","parent","error","code","message","toConsumableArray","then","catch","e","__webpack_exports__"],"mappings":"wIAOIA,kFC6BWC,cA9Bb,SAAAA,EAAYC,GAAa,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IACvBE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,QAHKJ,SAEkB,EAEvBC,EAAKD,IAAMA,EAFYC,uMAKAO,OAAeC,SAASC,QAAQ,CACrDC,OAAQ,gBACRC,OAAQ,CAAC,CACPC,YAAYX,OAAAY,EAAA,EAAAZ,CAAA,GACTE,KAAKJ,IAAM,sBAJZe,2BAQCA,8KAGaC,yHAAwD,sBACpER,OAAeC,SAASC,QAAQ,CACtCC,OAAQP,KAAKJ,IACbY,OAAQ,CACLI,EAAsBN,4JAvBCO,WDK5BC,EAAa,EAuBFC,EALuB,CACpCC,QAjBoB,eAAAC,EAAAnB,OAAAoB,EAAA,EAAApB,CAAAqB,EAAAC,EAAAC,KAAG,SAAAC,EAAO1B,GAAP,OAAAuB,EAAAC,EAAAG,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cACvBhC,EAAY,IAAIC,EAAkBC,GADX4B,EAAAE,KAAA,EAEjBhC,EAAUsB,UAFO,cAAAQ,EAAAG,OAAA,UAGhB,GAHgB,wBAAAH,EAAAI,SAAAN,MAAH,gBAAAO,GAAA,OAAAZ,EAAAa,MAAA9B,KAAA+B,YAAA,GAkBpBC,SAZyB,SAACpB,GAC1B,IAAKlB,EACH,MAAM,IAAIuC,MAAM,iBAElB,OAAOvC,EAAUsC,SAAS,CACxBlB,WAAYA,IACZR,QAASM,MEnBbR,OAAO8B,iBAAiB,UAAxB,eAAAjB,EAAAnB,OAAAoB,EAAA,EAAApB,CAAAqB,EAAAC,EAAAC,KAAmC,SAAAC,EAAOa,GAAP,OAAAhB,EAAAC,EAAAG,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,UACjCU,QAAQC,IAAI,SAAUF,EAAGG,QACzBF,QAAQC,IAAI,OAAQF,EAAGvB,MACA,iBAAnBuB,EAAGvB,KAAKL,OAHqB,CAAAiB,EAAAE,KAAA,eAI9BS,EAAGI,OAAeC,YAAY,CAC7BC,QAAS,MACTC,OAAQC,EACRC,GAAIT,EAAGvB,KAAKgC,IACXT,EAAGG,QARyBd,EAAAG,OAAA,oBAW5BZ,EAAcoB,EAAGvB,KAAKL,QAXM,CAAAiB,EAAAE,KAAA,eAY/BtB,OAAOyC,OAAOL,YAAY,CACxBC,QAAS,MACTK,MAAO,CACLC,KAAM,MACNC,QAAS,oBAEXJ,GAAIT,EAAGvB,KAAKgC,IACXT,EAAGG,QAnByBd,EAAAG,OAAA,iBAsBjCZ,EAAcoB,EAAGvB,KAAKL,QAAtBuB,MAAAf,EAAajB,OAAAmD,EAAA,EAAAnD,CAAoBqC,EAAGvB,KAAKJ,SAAQ0C,KAAK,SAACvC,GACrDP,OAAOyC,OAAOL,YAAY,CACxBC,QAAS,MACTC,OAAQ/B,EACRiC,GAAIT,EAAGvB,KAAKgC,IACXT,EAAGG,UACLa,MAAM,SAACC,GACPjB,EAAGI,OAAeC,YAAY,CAC7BC,QAAS,MACTK,MAAO,CACLC,KAAM,MACNC,QAASI,EAAEJ,SAEbJ,GAAIT,EAAGvB,KAAKgC,IACXT,EAAGG,UApCyB,wBAAAd,EAAAI,SAAAN,MAAnC,gBAAAO,GAAA,OAAAZ,EAAAa,MAAA9B,KAAA+B,YAAA,IAwCesB,EAAA","file":"static/js/main.21e02411.chunk.js","sourcesContent":["import { Connect, SendData } from \"../__GENERATED_TYPES__\";\nimport MetaMaskTransport from \"../transports/MetaMaskTransport\";\n\nexport interface IMethodMapping {\n  [methodName: string]: (...params: any) => Promise<any>;\n}\n\nlet transport: MetaMaskTransport | undefined;\nlet internalID = 0;\n\nconst connect: Connect = async (uri) => {\n  transport = new MetaMaskTransport(uri);\n  await transport.connect();\n  return true;\n};\n\nconst sendData: SendData = (data) => {\n  if (!transport) {\n    throw new Error(\"Not Connected\");\n  }\n  return transport.sendData({\n    internalID: internalID++,\n    request: data,\n  });\n};\n\nconst methodMapping: IMethodMapping = {\n  connect,\n  sendData,\n};\n\nexport default methodMapping;\n","import { Transport } from \"@open-rpc/client-js/build/transports/Transport\";\nimport { JSONRPCRequestData, IJSONRPCData } from \"@open-rpc/client-js/build/Request\";\n\nclass MetaMaskTransport extends Transport {\n  public uri: string;\n\n  constructor(uri: string) {\n    super();\n    this.uri = uri;\n  }\n  public async connect(): Promise<any> {\n    const results = await (window as any).ethereum.request({\n      method: \"wallet_enable\",\n      params: [{\n        wallet_snap: {\n          [this.uri]: {},\n        }\n      }],\n    });\n    return results;\n  }\n\n  public async sendData(data: JSONRPCRequestData, timeout: number | undefined = 5000): Promise<any> {\n    return (window as any).ethereum.request({\n      method: this.uri,\n      params: [\n        (data as IJSONRPCData).request,\n      ],\n    });\n  }\n\n  public close(): void {\n    // noop\n  }\n}\n\nexport default MetaMaskTransport;\n","import openrpcDocument from \"./openrpc.json\";\nimport methodMapping from \"./methods/methodMapping\";\n\nwindow.addEventListener(\"message\", async (ev: MessageEvent) => {\n  console.log(\"origin\", ev.origin); //tslint:disable-line\n  console.log(\"data\", ev.data); //tslint:disable-line\n  if (ev.data.method === \"rpc.discover\") {\n    (ev.source as any).postMessage({\n      jsonrpc: \"2.0\",\n      result: openrpcDocument,\n      id: ev.data.id,\n    }, ev.origin);\n    return;\n  }\n  if (!methodMapping[ev.data.method]) {\n    window.parent.postMessage({\n      jsonrpc: \"2.0\",\n      error: {\n        code: 32009,\n        message: \"Method not found\",\n      },\n      id: ev.data.id,\n    }, ev.origin);\n    return;\n  }\n  methodMapping[ev.data.method](...ev.data.params).then((results: any) => {\n    window.parent.postMessage({\n      jsonrpc: \"2.0\",\n      result: results,\n      id: ev.data.id,\n    }, ev.origin);\n  }).catch((e: Error) => {\n    (ev.source as any).postMessage({\n      jsonrpc: \"2.0\",\n      error: {\n        code: 32329,\n        message: e.message,\n      },\n      id: ev.data.id,\n    }, ev.origin);\n  });\n});\n\nexport default {};\n"],"sourceRoot":""}